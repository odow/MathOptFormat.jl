<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MathOptFormat · MathOptFormat</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathOptFormat</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">MathOptFormat</a><ul class="internal"><li><a class="toctext" href="#Background-1">Background</a></li><li><a class="toctext" href="#The-MathOptInterface-Standard-Form-1">The MathOptInterface Standard Form</a></li><li><a class="toctext" href="#Why-JSON?-1">Why JSON?</a></li><li><a class="toctext" href="#The-Format-1">The Format</a></li><li><a class="toctext" href="#Example-1">Example</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">MathOptFormat</a></li></ul><a class="edit-page" href="https://github.com/odow/MathOptFormat.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MathOptFormat</span><a class="fa fa-bars" href="#"></a></div></header><p><em>The file format is under active development. No backward compatibility yet!</em></p><h2><a class="nav-anchor" id="Background-1" href="#Background-1">Background</a></h2><p>In order to use an optimization solver, it is necessary to communicate a model instance to the solver <a href="#footnote-1">[1]</a>. Many different instance formats have been proposed over the years, but only a few (such as MPS) have become the industry standard.</p><p>Each format is a product of its time in history, and the problem class it tried to address. For example, we retain the rigid input format of the MPS file that was designed for 1960&#39;s punchcards despite the obsolescence of this technology <a href="#footnote-2">[2]</a>. Although it has since been  extended to problem classes such as nonlinear and stochastic linear programming, MPS was not designed with extensibility in mind. This has led some authors (such as <a href="#footnote-3">[3]</a>) to conclude that developing a new format is easier than extending the existing MPS format.</p><p>The LP file-format also dates back to the work of Orchard-Hays who attempted to correct the &#39;&#39;mistakes&#39;&#39; of the MPS file-format by creating a human-readable, row-oriented format for mathematicians <a href="#footnote-2">[2]</a>. However, due to its age, there is no longer a single standard for the LP file-format. This has led to subtle differences between implementations in different readers that hampers the usefulness of the format as a format for interchange. Much like the MPS file, it is also limited in the types of problems it can represent and was not designed for extensibility.</p><p>In contrast to the LP file, the .NL file explicitly aims for machine-readability at the expense of human-readability <a href="#footnote-5">[5]</a>. It is also considerably more flexible in the problem classes it can represent (in particular, arbitrary nonlinear functions are supported). However, once again, the format is not extensible to new problem formats, and lacks support for conic problems.</p><p>More recently, considerable work has been put into developing the OSiL format <a href="#footnote-4">[4]</a>. In developing OSiL, Fourer et al. idenfied many of the challenges and limitations of previous formats and attempted to overcome them. In particular, they choose to use XML as the basis for their format. This removed the burden of writing custom readers and writers for each programming language that wished to interface with optimization software and allowed more focus on the underlying data-structures. XML is also human-readable and can be rigidly specified with a schema to prevent the profilferation of similar, but incompatible versions. The XML approach also allows for easy extensibility and can support multiple problem classes including nonlinear, stochastic, and conic.</p><p>However, despite the many apparent advantages of the OSiL format, we believe it has enough short-comings to justify the development of a new instance format. Two of the main reasons are the verbosity of the XML format, and the lack of a strong, extensible standard form.</p><h3><a class="nav-anchor" id="Project-Goals-1" href="#Project-Goals-1">Project Goals</a></h3><p>With this understanding of the history and evolution of different file-formats, the following goals guided our development of the MathOptFormat:</p><ul><li><strong>Human-readable</strong>: the format should be able to be read and edited by a  human.</li><li><strong>Machine-readable</strong>: the format should be able to be read by a variety of different programming languages without needing to write custom parsers in each language.</li><li><strong>Standardized</strong>: the format should conform to a well described  &#39;&#39;standard-form&#39;&#39; that is unambiguous.</li><li><strong>Extensible</strong>: the format should be able to be easily extended to incorporate  new problem-classes as they arise.</li></ul><h2><a class="nav-anchor" id="The-MathOptInterface-Standard-Form-1" href="#The-MathOptInterface-Standard-Form-1">The MathOptInterface Standard Form</a></h2><p>MathOptInterface is a solver abstraction layer for mathematical optimization solvers <a href="#footnote-6">[6]</a>. One if the core design goals of MathOptInterface is for it to</p><blockquote><p><em>&quot;be simple and extensible, unifying linear, quadratic, and conic optimization, and seamlessly facilitate extensions to essentially arbitrary constraints and functions (e.g., indicator constraints, complementarity constraints, and piecewise linear functions).&quot;</em></p></blockquote><p>The MathOptInterface standard form problem is:</p><div>\[\begin{align}
    &amp; \min_{x \in \mathbb{R}^n} &amp; f_0(x)
    \\
    &amp; \;\;\text{s.t.} &amp; f_i(x) &amp; \in \mathcal{S}_i &amp; i = 1 \ldots m
\end{align}\]</div><p>where <span>$f_i(x)$</span> is an arbitrary function and <span>$\mathcal{S}_i$</span> is an arbitrary set.</p><p>For example, instead of thinking of the constraint <span>$3x + y \le 1$</span> as a &#39;&#39;less than or equal to&quot; constraint, we can think of the constraint as enforcing the function <span>$3x + y$</span> to be inside the set <span>$(-\infty, 1]$</span>.</p><p>This approach turns out to be very general, as instead of thinking of variable as being &#39;&#39;binary&#39;&#39;, we say the function <span>$x$</span> belongs to the set <span>$\{0, 1\}$</span>. Instead of a variable being semicontinuous, we say the function <span>$x$</span> belongs to the set <span>${0} \cup [l, u]$</span>.</p><h2><a class="nav-anchor" id="Why-JSON?-1" href="#Why-JSON?-1">Why JSON?</a></h2><p>One reason for developing a new instance format rather than improving OSiL is its use of XML. Although XML has many advantages (a strictly defined schema for example), the format is almost too general (and too verbose) for our purposes.</p><p>In constrast, JSON is a much simpler format, and is only able to store six different data types: <code>string</code>, <code>number</code>, <code>object</code>, <code>array</code>, <code>boolean</code> and <code>null</code>.</p><p>In almost all programming languages, these map directly to native language constructs (<code>object</code> being a dictionary or a key-value mapping).</p><p>https://www.json.org/xml.html</p><h2><a class="nav-anchor" id="The-Format-1" href="#The-Format-1">The Format</a></h2><p>A MathOptFormat instance is a text representation of the model as a JSON object. The object must have the following fields: <code>version</code>, <code>sense</code>, <code>variables</code>, <code>objective</code> and <code>constraints</code>. Users may also choose to add optional fields such as <code>author</code> to provide contextual information for humans reading the instance. Parsers may choose to ignore these fields.</p><h3><a class="nav-anchor" id="Versioning-1" href="#Versioning-1">Versioning</a></h3><p>The <code>version</code> field stores number of the earliest version of MathOptFormat that supported all the features in the instance.</p><pre><code class="language-none">&quot;version&quot;: 0</code></pre><h3><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h3><p>The <code>variables</code> field contains a list of objects (one for each variable in the model). Each variable object must contain at least the field <code>name</code> which records a unique string. Duplicate names are not allowed. In addition, the variable object can optionally contain any MathOptInterface variable attributes (for example <code>VariablePrimalStart</code>).</p><pre><code class="language-none">&quot;variables&quot;: [
    {&quot;name&quot;: &quot;x&quot;},
    {&quot;name&quot;: &quot;y&quot;, &quot;VariablePrimalStart&quot;: 1.0}
]</code></pre><h3><a class="nav-anchor" id="MathOptInterface-Functions-1" href="#MathOptInterface-Functions-1">MathOptInterface Functions</a></h3><p>A MathOptInterface function can be represented by a JSON object. Every function must have the field <code>head</code> which contains a string that is identical to the name of the MathOptInterface function.</p><p>In addition, there must be a one-to-one mapping between the field names of the MathOptInterface type, and the fields in the JSON object. However, instead of referring to variables in the model using <code>VariableIndex</code>s, the MathOptFormat version uses the string that corresponds to the name of the variable in the list <code>variables</code> (defined above).</p><p>For example, the <code>SingleVariable</code> function has a single field <code>variable</code>. For example:</p><pre><code class="language-none">{
    &quot;head&quot;: &quot;SingleVariable&quot;,
    &quot;variable&quot;: &quot;x&quot;
}</code></pre><h3><a class="nav-anchor" id="MathOptInterface-Sets-1" href="#MathOptInterface-Sets-1">MathOptInterface Sets</a></h3><p>MathOptInterface Sets are represented in a similar manner to MathOptInterface functions.</p><pre><code class="language-none">{
    &quot;head&quot;: &quot;LessThan&quot;,
    &quot;upper&quot;: 1.0
}</code></pre><h3><a class="nav-anchor" id="Objective-Functions-1" href="#Objective-Functions-1">Objective Functions</a></h3><p>The <code>objectives</code> field contains a list of MathOptInterface function (<span>$f_0(x)$</span>).</p><p>The <code>sense</code> field must contain a string that is either <code>&quot;min&quot;</code>, <code>&quot;max&quot;</code>, or <code>&quot;feasibility&quot;</code>. No other values are allowed.</p><pre><code class="language-none">&quot;objectives&quot;: [
    {
        &quot;sense&quot;: &quot;min&quot;,
        &quot;function&quot;: {&quot;head&quot;: &quot;SingleVariable&quot;, &quot;variable&quot;: &quot;x&quot;}
    }
]</code></pre><h3><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h3><p>Each constraint is a JSON object with two required fields: <code>set</code>, and <code>function</code>. The values associated with these fields must be a valid MathOptInterface set and function respectively. In addition, the object can contain MathOptInterface constraint attributes such as <code>name</code>, <code>ConstraintPrimalStart</code>, and <code>ConstraintDualStart</code>.</p><pre><code class="language-none">{
    &quot;constraints&quot;: [
        {
            &quot;name&quot;: &quot;c1&quot;,
            &quot;set&quot;: {
                &quot;head&quot;: &quot;LessThan&quot;, &quot;upper&quot;: 1.0
            },
            &quot;function&quot;: {
                &quot;head&quot;: &quot;ScalarAffineFunction&quot;,
                &quot;terms&quot;: [
                    {
                        &quot;head&quot;: &quot;ScalarAffineTerm&quot;,
                        &quot;coefficient&quot;: 1.0,
                        &quot;variable_index&quot;: &quot;x&quot;}
                ],
                &quot;constant&quot;: 1.0

            }
        }

    ]
}</code></pre><h2><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h2><p>Consider the following LP:</p><div>\[\begin{align}
    &amp; \min_{x,y} &amp; 2x + y
    \\
    &amp; \;\;\text{s.t.} &amp; x + y &gt;= 1
    \\
    &amp;                 &amp; x, Binary
\end{align}\]</div><h3><a class="nav-anchor" id="MathOptFormat-1" href="#MathOptFormat-1">MathOptFormat</a></h3><p>We can represent this in the MathOptFormat as</p><pre><code class="language-none">{
    &quot;author&quot;: &quot;Oscar Dowson&quot;,
    &quot;description&quot;: &quot;A simple example for the MathOptFormat documentation&quot;,
    &quot;name&quot;: &quot;MathOptFormat Model&quot;,
    &quot;version&quot;: &quot;0.0&quot;,
    &quot;variables&quot;: [{&quot;name&quot;: &quot;x&quot;}, {&quot;name&quot;: &quot;y&quot;}],
    &quot;objectives&quot;: [
        {
            &quot;sense&quot;: &quot;min&quot;,
            &quot;function&quot;: {
                &quot;head&quot;: &quot;ScalarAffineFunction&quot;,
                 &quot;terms&quot;: [
                     {
                         &quot;head&quot;: &quot;ScalarAffineTerm&quot;,
                         &quot;coefficient&quot;: 2.0,
                         &quot;variable_index&quot;: &quot;x&quot;
                     },
                     {
                         &quot;head&quot;: &quot;ScalarAffineTerm&quot;,
                         &quot;coefficient&quot;: 1.0,
                         &quot;variable_index&quot;: &quot;y&quot;
                     }
                ],
                &quot;constant&quot;: 0.0
            }
        }
     ],
     &quot;constraints&quot;: [
         {
             &quot;name&quot;: &quot;x ∈ {0,1}&quot;,
             &quot;function&quot;: {&quot;head&quot;: &quot;SingleVariable&quot;, &quot;variable&quot;: &quot;x&quot;},
             &quot;set&quot;: {&quot;head&quot;: &quot;ZeroOne&quot;}
         },
         {
             &quot;name&quot;: &quot;x+y≥1&quot;
             &quot;function&quot;: {
                 &quot;head&quot;: &quot;ScalarAffineFunction&quot;,
                 &quot;terms&quot;: [
                    {
                        &quot;head&quot;: &quot;ScalarAffineTerm&quot;,
                        &quot;coefficient&quot;: 1.0,
                        &quot;variable_index&quot;: &quot;x&quot;,
                    },
                    {
                        &quot;head&quot;: &quot;ScalarAffineTerm&quot;,
                        &quot;coefficient&quot;: 1.0,
                        &quot;variable_index&quot;: &quot;y&quot;
                    }
                ],
                &quot;constant&quot;: 0.0
             },
             &quot;set&quot;: {&quot;head&quot;: &quot;GreaterThan&quot;, &quot;lower&quot;: 1.0},
         }
     ]
}</code></pre><p>Note that in addition to the required fields, we can store additional information (such as the <code>author</code> and a <code>description</code> of the model) that is not necessary to define the model instance, but is useful human-readable metadata.</p><h3><a class="nav-anchor" id="LP-1" href="#LP-1">LP</a></h3><p>Compared to the LP formulation (below), the MathOptFormat vesion is verbose and less human-readable. However, it does not require a specialised parser to read, conforms to a well standardized specification, and is extensible.</p><pre><code class="language-none">/ Author: Oscar Dowson
/ Description: A simple example for the MathOptFormat documentation
Minimize
obj: 2x + y
Subject To
c1: x + y &gt;= 1
Bounds
y free
Binary
x
End</code></pre><h3><a class="nav-anchor" id="OSiL-1" href="#OSiL-1">OSiL</a></h3><p>Compared to the OSiL version (below), we would argue that the MathOptFormat is more human-readable, better standardized, and more extensible.</p><pre><code class="language-none">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;osil xmlns=&quot;os.optimizationservices.org&quot;&gt;
    &lt;instanceHeader&gt;
        &lt;name&gt;MathOptFormat Example&lt;/name&gt;
        &lt;source&gt;Oscar Dowson&lt;/source&gt;
        &lt;description&gt;A simple example for the MathOptFormat documentation&lt;/description&gt;
    &lt;/instanceHeader&gt;
    &lt;instanceData&gt;
        &lt;variables numberOfVariables=&quot;2&quot;&gt;
            &lt;var lb=&quot;-INF&quot; name=&quot;x&quot; type=&quot;B&quot;/&gt;
            &lt;var lb=&quot;-INF&quot; name=&quot;y&quot;/&gt;
        &lt;/variables&gt;
        &lt;objectives numberOfObjectives=&quot;1&quot;&gt;
            &lt;obj maxOrMin=&quot;min&quot; numberOfObjCoef=&quot;2&quot;&gt;
                &lt;coef idx=&quot;1&quot;&gt;2&lt;/coef&gt;
                &lt;coef idx=&quot;2&quot;&gt;1&lt;/coef&gt;
            &lt;/obj&gt;
        &lt;/objectives&gt;
        &lt;constraints numberOfConstraints=&quot;1&quot;&gt;
            &lt;con lb=&quot;1.0&quot;/&gt;
        &lt;/constraints&gt;
        &lt;linearConstraintCoefficients numberOfValues=&quot;2&quot;&gt;
            &lt;start&gt;
                &lt;el&gt;0&lt;/el&gt;&lt;el&gt;1&lt;/el&gt;
            &lt;/start&gt;
            &lt;colIdx&gt;
                &lt;el&gt;0&lt;/el&gt;&lt;el&gt;1&lt;/el&gt;
            &lt;/colIdx&gt;
            &lt;value&gt;
                &lt;el&gt;1&lt;/el&gt;&lt;el&gt;1&lt;/el&gt;
            &lt;/value&gt;
        &lt;/linearConstraintCoefficients&gt;
    &lt;/instanceData&gt;
&lt;/osil&gt;</code></pre><h3><a class="nav-anchor" id="MathOptFormat.jl-1" href="#MathOptFormat.jl-1">MathOptFormat.jl</a></h3><pre><code class="language-julia">using MathOptFormat
const MOI = MathOptFormat.MOI

model = MathOptFormat.Model{Float64}()

# Create variables
(x, y) = MOI.add_variables(model, 2)
MOI.set(model, MOI.VariableName(), x, &quot;x&quot;)
MOI.set(model, MOI.VariableName(), y, &quot;y&quot;)

# Set objective
MOI.set(model, MOI.ObjectiveSense(), MOI.MinSense)
MOI.set(model,
    MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),
    MOI.ScalarAffineFunction(
        MOI.ScalarAffineTerm.([2.0, 1.0], [x, y]),
        0.0)
)

# The constraint: x+y≥1 becomes x+y ∈ [1, ∞)
c1 = MOI.add_constraint(model,
    MOI.ScalarAffineFunction(
        MOI.ScalarAffineTerm.([1.0, 1.0], [x, y]),
        0.0),
    MOI.GreaterThan(1.0)
)
MOI.set(model, MOI.ConstraintName(), c1, &quot;x+y≥1&quot;)

# The constraint: x, Binary becomes x ∈ {0, 1}
c2 = MOI.add_constraint(model,
    MOI.SingleVariable(x),
    MOI.ZeroOne()
)
MOI.set(model, MOI.ConstraintName(), c2, &quot;x ∈ {0,1}&quot;)

# Write the model to file
MOI.write_to_file(model, &quot;example.mof.json&quot;)</code></pre><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Gassmann, H., Ma, J., Martin, K. (2010). <a href="https://www.coin-or.org/OS/publications/instanceformats_encyclopedia2009.pdf">Instance Formats for Mathematical Optimization Models</a>. In <em>Wiley Encyclopedia of Operations Research and Management Science</em>.</p></div><div class="footnote" id="footnote-2"><a href="#footnote-2"><strong>[2]</strong></a><p>Orchard-Hays, W. (1984). <a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4640725">History of Mathematical Programming Systems</a>. <em>Annals of the History of Computing, 6</em>(3).</p></div><div class="footnote" id="footnote-3"><a href="#footnote-3"><strong>[3]</strong></a><p>Friberg, H. (2014). <em><a href="http://orbit.dtu.dk/files/88492586/Conic_Benchmark_Format.pdf">The conic benchmark format: version 1 - technical reference manual</a></em> (Technical Report E-0047). Department of Wind Energy, Technical University of Denmark.</p></div><div class="footnote" id="footnote-4"><a href="#footnote-4"><strong>[4]</strong></a><p>Fourer, R., Jun M., Kipp M. (2010). <a href="https://www.coin-or.org/OS/publications/OSiL%201_0%20FINAL.pdf">OSiL: An Instance Language for Optimization</a>. <em>Computational Optimization and Applications 45</em>(1): 181–203.</p></div><div class="footnote" id="footnote-5"><a href="#footnote-5"><strong>[5]</strong></a><p>Gay, D. (1995). <a href="https://cfwebprod.sandia.gov/cfdocs/CompResearch/docs/nlwrite20051130.pdf"><em>Writing .nl Files</em></a> (SAND2005-7907P). Sandia National Laboratories, Albuquerque, NM.</p></div><div class="footnote" id="footnote-6"><a href="#footnote-6"><strong>[6]</strong></a><p>Lubin, M. et al. (2017). <a href="http://www.juliaopt.org/MathOptInterface.jl/latest/">MathOptInterface.jl</a>. URL:<a href="http://www.juliaopt.org/MathOptInterface.jl/latest/">MathOptInterface.jl</a></p></div><footer><hr/></footer></article></body></html>
